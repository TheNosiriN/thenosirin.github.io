[!bold=An Excerpt from the PBRT chapter 9.1 - BSDF Representation]

[!bold]9.1 BSDF Representation
There are two components of pbrt’s representation of BSDFs: the BxDF interface and its implementations (described in Section 9.1.2) and the BSDF class (described in Section 9.1.5). The former models specific types of scattering at surfaces, while the latter provides a convenient wrapper around a pointer to a specific BxDF implementation. The BSDF class also centralizes general functionality so that BxDF implementations do not individually need to handle it, and it records information about the local geometric properties of the surface.

[!bold]9.1.1 Geometric Setting and Conventions
Reflection computations in pbrt are performed in a reflection coordinate system where the two tangent vectors and the normal vector at the point being shaded are aligned with the , , and  axes, respectively (Figure 9.2). All direction vectors passed to and returned from the BxDF evaluation and sampling routines will be defined with respect to this coordinate system. It is important to understand this coordinate system in order to understand the BxDF implementations in this chapter.

Section 3.8 introduced a range of utility functions—like SinTheta(), CosPhi(), etc.—that efficiently evaluate trigonometric functions of unit vectors expressed in Cartesian coordinates matching the convention used here. They will be used extensively in this chapter, as quantities like the cosine of the elevation angle play a central role in most reflectance models.

[!image = pha09f02.jpg]
Figure 9.2: The Basic BSDF Coordinate Setting. The shading coordinate system is defined by the orthonormal basis vectors . We will orient these vectors such that they lie along the , , and  axes in this coordinate system. Direction vectors  in rendering space are transformed into the shading coordinate system before any of the BRDF or BTDF methods are called.

We will frequently find it useful to check whether two direction vectors lie in the same hemisphere with respect to the surface normal in the BSDF coordinate system; the SameHemisphere() function performs this check.

<<Spherical Geometry Inline Functions>>+=
[!code =
bool SameHemisphere(Vector3f w, Vector3f wp) {
    return w.z * wp.z > 0;
}
]
There are some additional conventions that are important to keep in mind when reading the code in this chapter and when adding BRDFs and BTDFs to pbrt:

The incident light direction  and the outgoing viewing direction  will both be normalized and outward facing after being transformed into the local coordinate system at the surface. In other words, the directions will not model the physical propagation of light, which is helpful in bidirectional rendering algorithms that generate light paths in reverse order.
In pbrt, the surface normal  always points to the “outside” of the object, which makes it easy to determine if light is entering or exiting transmissive objects: if the incident light direction  is in the same hemisphere as , then light is entering; otherwise, it is exiting. Therefore, the normal may be on the opposite side of the surface than one or both of the  and  direction vectors. Unlike many other renderers, pbrt does not flip the normal to lie on the same side as .
The local coordinate system used for shading may not be exactly the same as the coordinate system returned by the Shape::Intersect() routines from Chapter 6; it may have been modified between intersection and shading to achieve effects like bump mapping. See Chapter 10 for examples of this kind of modification.
